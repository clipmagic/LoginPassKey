<?php
namespace ProcessWire;

/**
 * WebAuthn for ProcessWire Users
 *
 * Copyright:
 *
 * Clip Magic - Prue Rowland
 * Web: www.clipmagic.com.au
 * Email: admin@clipmagic.com.au
 * Licensed under MIT, see LICENSE.TXT
 *
 * For use with:
 * ProcessWire 3.x
 * Copyright (C) 2014 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 **/

class LoginPassKey extends WireData implements Module, ConfigurableModule
{
    public $transports = ['hybrid', 'internal'];

//    public $attestationFormat = 'none';
    public $attestationFormat = 'none';

    public $userVerification = 'preferred';

    public $residentKey = 'preferred';

    public $userDisplayName = null;

    public $crossPlatformAttachment = null;

    public function getModuleConfigInputfields(array $data)
    {
        $modules = wire('modules');
        $sanitizer = wire('sanitizer');

        $fields = new InputfieldWrapper();

        // field for additional info/help text

        $field = $modules->get('InputfieldMarkup');
        $field->name = 'header_text';
        $field->columnWidth = 100;
        $field->markupText = $this->_("After saving, if your User template(s) contain email fields, you'll be given the opportunity to select one. The user can then login with either their username or the selected email field address. Email addresses MUST be unique.");
        $fields->add($field);


        // Authentication options
        $fieldset = $modules->get('InputfieldFieldset');
        $fieldset->attr('name+id', 'activate');
        $fieldset->label = $this->_('Activate module');

        // Enable module load in Frontend
        $field = $modules->get('InputfieldCheckbox');
        $field->name = 'enabled';
        $field->value = null;
        $field->columnWidth	= 50;
        $field->label = $this->_("Enable Frontend Passkey login");
        if (isset($data['enabled']) && $data['enabled'] !== '') {
            $field->value = $data['enabled'];
            $field->attr('checked', 'checked');
        }
        $fieldset->add($field);
        // Enable Passkey login to Admin
        $field = $modules->get('InputfieldCheckbox');
        $field->name = 'enabledAdmin';
        $field->value = null;
        $field->columnWidth	= 50;
        $field->label = $this->_("Enable Admin Passkey login");
        if (isset($data['enabledAdmin']) && $data['enabledAdmin'] !== '') {
            $field->value = $data['enabledAdmin'];
            $field->attr('checked', 'checked');
        }
        $fieldset->add($field);


        $fields->add($fieldset);

        // Authentication options
        $fieldset = $modules->get('InputfieldFieldset');
        $fieldset->attr('name+id', 'authoptions');
        $fieldset->label = $this->_('Authentication options');

        // Application name
        $field = $modules->get('InputfieldText');
        $field->name = 'appname';
        $field->label = $this->_("Application name");
        $field->columnWidth	= 50;
        $field->notes($this->_("Friendly application name")); ;
        if(!empty($data['appname']))  $field->attr('value', $this->wire()->sanitizer->text($data['appname']));
        $fieldset->add($field);

        // Replying party host
        $field = $modules->get('InputfieldText');
        $field->name = 'rp';
        $field->label = $this->_("Host name (Replying Party)");
        $field->columnWidth	= 50;
        $field->notes($this->_("Leave blank to default to config->host. Must match the URL defined in your .htaccess file, eg with/without 'www'"));
        $field->value = !empty($data['rp']) ? $sanitizer->text($data['rp']) : $this->wire('config')->httpHost;
        $fieldset->add($field);
        $fields->add($fieldset);

        // ProcessWire User settings
        $fieldset = $modules->get('InputfieldFieldset');
        $fieldset->attr('name+id', 'pwuserinfo');
        $fieldset->label = $this->_('ProcessWire User Info');

        // PW User template
        $field = $modules->get('InputfieldRadios');
        $field->name = 'user_template';
        $field->label = $this->_("User template");
        $field->columnWidth	= 33;
        $field->required = 1;
        $config = $this->wire('config');
        $tpls = wire('templates');
        foreach ($config->userTemplateIDs as $templateID) {
            $tpl = $tpls->get($templateID);
            $attrs = $tpl->id === $config->userTemplateID ? ["checked" => "checked"] : []; // default User template id
            $field->addOption($templateID, $tpl->get("label|name"), $attrs);
        }
        if (!empty($data['user_template'])) $field->attr('value', $data['user_template']);
        $fieldset->add($field);

        // ProcessWire email field from selected template
        $field = $modules->get('InputfieldRadios');
        $field->name = 'user_fld';
        $field->label = $this->_("Identify User by username or email field");
        $field->columnWidth	= 33;
        $field->notes = $this->_("After saving, a list of eligible email fields will appear");

        $field->required = 1;
        $field->addOption('name', 'Username', ['selected' => 'selected']);
        if(!empty($data['user_template'])) {
            $tpl = $tpls->get($data['user_template']);
            foreach ($tpl->fieldgroup->fields->findByType("FieldtypeEmail") as $tplField) {
                $field->addOption($tplField->name, $tplField->get("label|name"));
            }
        }
        if (!empty($data['user_fld'])) $field->attr('value', $data['user_fld']);
        $fieldset->add($field);

        // Allowed roles
        $field = $modules->get('InputfieldCheckboxes');
        $field->name = 'roles';
        $field->label = $this->_("User roles permitted to use WebAuthn");
        $field->required = 1;
        $field->columnWidth	= 34;
        $roles = $this->wire('roles')->find('limit=200');
        $config = $this->wire('config');
        if ($roles->count > 0) {
            foreach ($roles as $role) {
                if($role->id === $config->guestUserRolePageID) continue;
                $field->addOption($role->id, $role->name);
            }
        }
        if (!empty($data['roles'])) $field->attr('value', $data['roles']);
        $fieldset->add($field);

        // API endpoint
        $field = $modules->get('InputfieldText');
        $field->name = 'api_url';
        $field->columnWidth	= 50;
        $field->label = $this->_("Path to your API ENDPOINT");
        $field->value = "/lpk-api/";
        $field->notes = $this->_("Default is /lpk-api/");
        if(!empty($data['api_url']))
            $field->value = $data['api_url'];
        $field->required = 1;
        $fieldset->add($field);
        $fields->add($fieldset);

        // Redirect on login
        $field = $modules->get('InputfieldText');
        $field->name = 'redirect_url';
        $field->columnWidth	= 50;
        $field->label = $this->_("Page to redirect to on login (Frontend only)");
        $field->value = "/";
        $field->notes = $this->_("ID or path");
        if(!empty($data['redirect_url']))
            $field->value = $data['redirect_url'];

        $fieldset->add($field);
        $fields->add($fieldset);

        return $fields;
    }

    public function construct()
    {
        parent::__construct();
    }

    public function init() : void
    {
        $this->addHookAfter('Page::render', $this, 'addScriptsFE');

        $this->wire()->addHookAfter('ProcessWire::ready', function($event) {
            if(!method_exists($event->page, 'render')) {
                // module & database need to be in place before going further
                if($event->page->rootParent->name === 'module') return;

                // Remove the input->get->logout, when using
                // LoginRegisterPro to prevent it blocking subsequent passkey logins
                $user = $this->wire('user');
                $input = $this->wire('input');
                $page = $this->wire('page');
                $session = $this->wire('session');
                if(!$user->isLoggedIn() && !!$input->get->logout) {
                    $session->redirect($page->url);
                }

                if($event->page->template->name === 'admin') {
                    $config = $this->wire('config');
                    $config->styles->add($config->urls($this) . $this->className() . ".css");
                }

                if($event->page->template->name === 'admin' && $this->enabledAdmin === 1) {
                    $session = $this->wire('session');
                    $session->setFor('lpk', 'inadmin', 1);
                    $event->page->addHookBefore('render', function ($event) {
                        $config = $this->wire('config');
                        $config->scripts->add($config->urls($this) . $this->className() . ".js");
                            $config->scripts->add($config->urls($this) . $this->className() . "Admin.js");
                    });

                    $event->page->addHookAfter('ProcessLogin::buildLoginForm', $this, 'addLoginBtn');

                    $user = $this->wire('user');
                    if(empty($session->getFor('lpk', 'success')) && $user->isLoggedIn()) {
                        // show passkey registration popup if not already logged in with passkey
                        $this->wire()->addHookAfter('Page::render', $this, 'registerAdmin');
                    }
                }
            }
        });


        $this->addHook('Page::lpkFindUser', $this, 'lpkFindUser');
        $this->addHook('Page::lpkGetArgs', $this, 'lpkGetArgs');
        $this->addHook('Page::lpkPreRegisterUser', $this, 'lpkPreRegisterUser');
        $this->addHook('Page::lpkRegisterUser', $this, 'lpkRegisterUser');
        $this->addHook('Page::lpkGetApiUrl', $this, 'lpkGetApiUrl');
        $this->addHook('Page::lpkGetRedirectUrl', $this, 'lpkGetRedirectUrl');
        $this->addHook('Page::lpkGetApiHttpUrl', $this, 'lpkGetApiHttpUrl');
        $this->addHook('Page::lpkGetWebAuthn', $this, 'lpkGetWebAuthn');
        $this->addHook('Page::lpkVerify', $this, 'lpkVerify');
        $this->addHook('Page::lpkGetUserByField', $this, 'lpkGetUserByField');
        $this->addHook('Page::lpkVerifyResponse', $this, 'lpkVerifyResponse');
        $this->addHook('Page::lpkGetErrorMessage', $this, 'lpkGetErrorMessage');
    }

    public function ___ready() : void
    {

    }

    #---------------------
    # Hooks
    #---------------------

    // Methods added to Page for use in templates

    public function lpkFindUser(HookEvent $event)
    {
        $user = $event->arguments(0);
        $event->return = $this->findUser($user);
    }

    public function lpkGetApiUrl(HookEvent $event)
    {
        $event->return = $this->api_url;
    }

    public function lpkGetRedirectUrl(HookEvent $event)
    {
        $event->return = $this->getRedirectUrl();
    }

    public function lpkGetApiHttpUrl(HookEvent $event)
    {
        $event->return = $this->getApiHttpUrl();
    }

    public function lpkGetArgs(HookEvent $event)
    {
        $event->return = $this->getlpkargs();
    }

    public function lpkPreRegisterUser(HookEvent $event)
    {
        $user = $event->arguments(0);
        $event->return = $this->preRegisterUser($user);
    }

    public function lpkGetUserByField(HookEvent $event)
    {
        $username = $event->arguments(0);
        $event->return = $this->getUserByField($username);
    }

    public function lpkGetErrorMessage(HookEvent $event)
    {
        $errormsg = $event->arguments(0);
        $event->return = $this->getErrorMessage($errormsg);
    }

    public function lpkRegisterUser(HookEvent $event)
    {
        $user = $event->arguments(0);
        $dn = $event->arguments(1);
        $event->return = $this->registerUser($user, $dn);
    }

    public function lpkVerify(HookEvent $event)
    {
        $user = $event->arguments(0);
        $event->return = $this->verifyUser($user);
    }

    public function lpkVerifyResponse(HookEvent $event)
    {
        $credData = $event->arguments(0);
        $challenge = $event->arguments(1);
        $signedData = $event->arguments(2);
        $event->return = $this->verifyResponse($credData, $challenge, $signedData);
    }

    // lpk only hooks
    public function addScriptsFE(HookEvent $event)
    {
        $return = $event->return;
        if(!$this->enabled) return;
        if($this->page->template->name !== 'admin') {
            $js = "<script src='" . $this->config()->urls($this) . $this->className() . ".js'></script>";
            $return = str_ireplace("</body>", $js . "</body>", $event->return);
        }
        $event->return = $return;
    }

    public function addLoginBtn(HookEvent $event)
    {
        if($this->user->isLoggedin()) return;

        $form = $event->return;
        $modules = $this->wire('modules');

        $passKeyButton = $modules->get('InputfieldButton');
        $passKeyButton->attr('id+name', 'lpk');
        $passKeyButton->addClass('top_button');
        $passKeyButton->attr('value', $this->_("Login with PassKey"));
        $passKeyButton->icon = 'key';
        $passKeyButton->attr('href', '#');
        $form->add($passKeyButton);

        $markUp = $modules->get('InputfieldMarkup');
        $markUp->attr('id+name', 'end');

        $html = "<div id='end' class='uk-margin'></div>";
        $modules = $this->wire('modules');
//        $apiUrl = $modules->getConfig('LoginPassKey')['api_url'];

        $apiUrl = $this->getApiHttpUrl();

        $html .= "<script>let apiUrl = '$apiUrl'</script>";
//        $html .= "if(!apiUrl)";
//        $html .= "let apiUrl = '$apiUrl'</script>";
        $markUp->value = $html;
        $form->add($markUp);

        $event->return = $form;
    }

    public function registerAdmin(HookEvent $event) {

        // Register a logged in front end user
        $session = $this->wire('session');


        $user = $this->wire('user');

        $lpk = $this->wire('modules')->get('LoginPassKey');
        $apiUrl = $this->api_url;

        $allowed = $this->userAllowed($user);

        if ($allowed !== false) {

            // auto trigger the registration process
            $fwd = new \stdClass();
            $fwd->fn = 'finduser';
            $fwd->un = $user->name;
            $fwd->next = 'register';

            $data = new \stdClass();
            $data->pk = $lpk->preRegisterUser($user);
            $data->next = 'register';

            $fwd->data = $data;
            $fwdJSON = \json_encode($fwd);

            $js  = "<script>";
            $js .= "let apiUrl = '$apiUrl'\n";
            $js .= "lpk.action(`${apiUrl}register`, $fwdJSON).then(res=> console.log(res))\n";
            $js .= "</script>";
            $return = str_ireplace("</body>", $js . "</body>", $event->return);

            // regardless of outcome, only run once per session
            $session->setFor('lpk', 'success', 'success');
            $event->return = $return;
        }
    }

    public function getApiHttpUrl()
    {
        return 'https://' . $this->rp  .  $this->api_url;
    }

    public function getRedirectUrl()
    {
        $sanitizer = $this->wire('sanitizer');
        $pages = $this->wire('pages');
        $pathOrId = \strpos($this->redirect_url,'/') !== false ? $sanitizer->text($this->redirect_url) : $sanitizer->int($this->redirect_url);

        return $pages->get($pathOrId)->url;
    }

    public function getDatabase()
    {
        return wire('database');
    }

    public function getTableName() : string
    {
       // return wire('sanitizer')->pageName($this->className());
        return $this->className(['lowercase']);
    }

    public function showUser()
    {
        return $this->user;
    }

    public function findUser(mixed $username = null)
    {
        /*
         * Scenarios
         * 1. Username field empty xx
         * 2. User is not logged in but device does support WebAuthn
         * 3. User is not logged in, device supports WebAuthn but username not found xx
         * 4. User is logged in but device does not support WebAuthn
         * 5. User is logged, device does support WebAuthn but user does not WebAuthn challenge set
         * 6. User roles do not match supported roles
         * 7. User roles match supported roles, user is not logged in and has WebAuthn challenge set
         * 8. User is loggedin and username does not match username input
         * 9. User logged in with PassKey
         */
        $output = new \stdClass();

        // Scenario 1
        if(empty($username)) {
            $output->fn = 'findUser';
            $output->msg = $this->getErrorMessage(60);
            $output->errno = 60;
            $output->next = 'end';
            return $output;
        }

        $users = wire('users');
        $user = wire('user');
        $feUser = $this->getUserByField($username);

        // Scenario 3
        if($feUser instanceof NullPage) {
        //    $output->id = $feUser->id;

            $output->msg = $this->getErrorMessage(65) . $username;
            $output->errno = 65;
            $output->fn = 'findUser';
            $output->next = 'end';
            return $output;
        }

        // Now to see if the FE User is allowed to use WebAuthn
        $allowed = $this->userAllowed($feUser);

        if(!$allowed) {
            $output->msg = $this->getErrorMessage(70);
            $output->errno = 70;
            $output->next = 'end';
            return $output;
        }

        // Superuser must be checked to allow Superusers to use WebAuthn
        // Superusers by default have all permissions
        if($feUser->isSuperuser() && !empty($this->roles[0]) )
            $allowed = true;

        if (!$allowed) {
            $output->un = $username;
            $output->msg = $this->getErrorMessage(80);
            $output->errno = 80;
            $output->fn = 'finduser';
            $output->next = 'end';
            return $output;
        }

        // Checked loggedin user is trying to log in as someone else
        if($feUser instanceof User && $user->isLoggedin() && $user->id !== $feUser->id) {
            $output->un = $username;
            $output->msg = $this->getErrorMessage(90);
            $output->errno = 90;
            $output->fn = 'finduser';
            $output->next = 'end';
            return $output;
        }

        // Scenario 9
        $loggedInWithPassKey = $this->wire('session')->getFor('lpk', 'success');
        if(!$user->isGuest()) {
            // User used a passkey to login
            $output->fn = 'findUser';
            if(!!$loggedInWithPassKey) {
                $output->msg = $this->getErrorMessage(66);
                $output->errno = 66;
                $output->next = 'end';
            } else {
//                $output->msg = $this->getErrorMessage(67);
                $output->errno = 67;
                $output->next = 'register';
            }
            //   $output->msg = !!($loggedInWithPassKey) ? $this->getErrorMessage(66) : $this->getErrorMessage(67);
            $output->un = $username;
            return $output;
        }

        // The user is legit and permitted to use WebAuthn
        if($feUser->isGuest() ) {
            $count = $this->_checklpkDB($feUser);
            // if count 0, they need to login with their password to register
            // otherwise, they have credentials in the DB which need to be verified

            $action = $count > 0 ? "verify" : "register";
            $output->un = $username;
            if($count > 0 ) {
                $output->verifyArgs = $this->prepareToValidate($feUser);
            }
            $output->fn = 'finduser';
            $output->next = $action;
            return $output;
        }

        // Action to take for loggedin user if in/out of lpkDB
        $output->un = $username;
        $output->fn = 'finduser';
        $output->next = "register";
        return $output;
    }

    public function getUserByField($username)
    {
        if(!$username instanceof User) {
            // it's the text-based name or email
            $sanitizer = $this->wire('sanitizer');

            $fld = $this->user_fld;
            $username = $sanitizer->text($username);
            $user = $this->wire('users')->get("name|$fld=$username");
        }
        return $user;
    }

    private function _checklpkDB($user)
    {
        // OK they're a valid user
        // Now let's see if they have existing credentials
        try {
            $count = false;
            while (!$count) {
                $db = wire('database');
                $sql = "SELECT COUNT(user_id) from " . $this->getTableName() . " where user_id=" . $user->id;
                $query = $db->prepare($sql);
                $query->closeCursor();
                $query->execute();
                $result = $query->fetchAll(\PDO::FETCH_ASSOC);
                return (int) $result[0]["COUNT(user_id)"];
            }
        } catch (WireException $e) {
            return "Database Error: " . $e->getMessage();
        }
    }

    private function _getCredentialsFromDB(User $user)
    {
        try {
            $db = wire('database');
            $sql = "SELECT `credential_id`, `public_key` from " . $this->getTableName() . " where user_id=" . $user->id;
            $query = $db->prepare($sql);
            $query->closeCursor();
            $query->execute();
            $result = $query->fetchAll(\PDO::FETCH_ASSOC);
            return $result;
        } catch (WireException $e) {
            return "Database Error: " . $e->getMessage();
        }
    }

    public function prepareToValidate($user)
    {
        $existingCredentials = $this->_getCredentialsFromDB($user);
        $lpkArgs = $this->getlpkargs();

        $args = new \stdClass();
        $args->publicKey = new \stdClass();
        $args->publicKey->timeout = 600000; // microseconds
        $args->publicKey->challenge = $this->_createChallenge();  // binary
        $args->publicKey->userVerification = $this->userVerification;
        $args->publicKey->rpId = $lpkArgs->rp;

        if (\is_array($existingCredentials) && \count($existingCredentials) > 0) {
            $args->publicKey->allowCredentials = [];

            foreach ($existingCredentials as $id) {
                $tmp = new \stdClass();
                $tmp->id = $id;
                $tmp->transports = $this->transports;
                $tmp->type = 'public-key';
                $args->publicKey->allowCredentials[] = $tmp;
                unset ($tmp);
             }
        }
        return $args;
    }


    private function _saveCredentialToDB($created)
    {
        // User has to be logged in to get to this point
        $user = $this->wire('user');
        $db = $this->wire('database');
        $userID = $user->id;
        $credentialID =$created->credentialId;

        $sql = <<<SQL
            INSERT INTO {$this->getTableName()}
            (
             user_id, 
             credential_id,
             public_key
             ) 
            VALUES 
            ( 
             :user_id,
             :credential_id,
             :public_key
            )
        SQL;

        $pem = $this->publicKeyToPem($created->publicKey);
        $query = $db->prepare($sql);
        $query->bindParam(":user_id", $userID);
        $query->bindParam(":credential_id", $credentialID);
        $query->bindParam(":public_key", $pem);
        $query->closeCursor();
        return $query->execute() ? true : false;
    }

    public function preRegisterUser($user)
    {
        // valid, loggedin user and can use Passkeys. Need to register for this app

        $lpkArgs = $this->getlpkargs();
        $lpkArgs->crossPlatformAttachment = $this->crossPlatformAttachment;
        $excludeRegistrations = $this->_getCredentialsFromDB($user);

        $args = new \stdClass();
        $args->publicKey = new \stdClass();

        // relying party
        $args->publicKey->rp = new \stdClass();
        $args->publicKey->rp->name = $lpkArgs->appname;
        $args->publicKey->rp->id = $lpkArgs->rp;

        $args->publicKey->authenticatorSelection = new \stdClass();
        $args->publicKey->authenticatorSelection->userVerification = $this->userVerification;

        $args->publicKey->authenticatorSelection->residentKey = $this->residentKey;
        $args->publicKey->authenticatorSelection->requireResidentKey = false;

        $crossPlatformAttachment = in_array($this->crossPlatformAttachment, ['platform', 'cross-platform'])
            ? $this->crossPlatformAttachment
            : 'platform';

        $args->publicKey->authenticatorSelection->authenticatorAttachment = $crossPlatformAttachment;

        // user
        $args->publicKey->user = new \stdClass();
        $args->publicKey->user->id = $user->id; // binary

        // Get the username or email address based on the User object
        $fld = $this->user_fld;
        $username = $user->$fld;

        $args->publicKey->user->name = $username;
        $args->publicKey->user->displayName = '';

        // supported algorithms
        $args->publicKey->pubKeyCredParams = [];

        $tmp = new \stdClass();
        $tmp->type = 'public-key';
        $tmp->alg = -8; // EdDSA
        $args->publicKey->pubKeyCredParams[] = $tmp;
        unset ($tmp);

        $tmp = new \stdClass();
        $tmp->type = 'public-key';
        $tmp->alg = -7; // ES256
        $args->publicKey->pubKeyCredParams[] = $tmp;
        unset ($tmp);

        $tmp = new \stdClass();
        $tmp->type = 'public-key';
        $tmp->alg = -257; // RS256
        $args->publicKey->pubKeyCredParams[] = $tmp;
        unset ($tmp);

        // attestation
        $args->publicKey->attestation = $this->attestationFormat;

        $args->publicKey->extensions = new \stdClass();
        $args->publicKey->extensions->exts = true;
        $args->publicKey->timeout = 600000; // microseconds
        $args->publicKey->challenge = $this->_createChallenge(); // binary

        // save challenge to the session in case we need it later
        //prevent re-registration by specifying existing credentials
        $args->publicKey->excludeCredentials = [];

        if (is_array($excludeRegistrations) && \count($excludeRegistrations) > 0) {
            foreach ($excludeRegistrations as $id) {
                $tmp = new \stdClass();
                $tmp->id = $id['credential_id'];
                $tmp->type = 'public-key';
                $tmp->transports = $this->transports;
                $args->publicKey->excludeCredentials[] = $tmp;
                unset ($tmp);
            }
        }
    return $args;
    }

    public function registerUser($user, $credData = null)
    {
        $output = new \stdClass();
        // finish up after regardless of outcome
        $output->next = 'end';
        $output->msg = $this->getErrorMessage(2);
        $output->errno = 2;


        if(is_null($credData)) {
            $output->errno = 3;
            $output->msg = $this->getErrorMessage(3);
            return $output;
        }

        $toDB = new \stdClass();
        $toDB->user_id = $user->id;
        $toDB->credentialId = $credData->id;
        $toDB->publicKey = $credData->response->publicKey;
        try {
            $output->created = $this->_saveCredentialToDB($toDB);
            if($output->created !== false) {
                $output->msg = $this->getErrorMessage(102);
                $output->errno = 102;
            }
        } catch(WireException $e) {
            $this->wire('log')->save($this->className(), "Database Exception: " . $e->getMessage());
            $output->created = 0;
            $output->msg = $this->getErrorMessage(2);
            $output->errno = 2;
        }
        return $output;
    }

    public function verifyUser($user) {

        $allowCredentials = [];
        $existingCredentials = $this->_getCredentialsFromDB($user);
        if(\count($existingCredentials) > 0) {
            foreach($existingCredentials as $credential) {
                $obj = new \stdClass();
                $obj->id = $credential['credential_id'];
                $obj->type = "public-key";
                $allowCredentials[] = $obj;
            }
        }

        $lpkArgs = $this->getlpkargs();

        $output = new \stdClass();
        $output->publicKey = new \stdClass();
        $output->publicKey->timeout = 420000000; // microseconds = 7mins
        $output->publicKey->challenge = $this->_createChallenge();  // binary
        $output->publicKey->userVerification = $this->userVerification;
        $output->publicKey->rpId = $lpkArgs->rp;
        $output->publicKey->authenticatorSelection = new \stdClass();
        if(!empty($allowCredentials))
            $output->publicKey->allowCredentials = $allowCredentials;
        return $output;
    }

//    public function verifyResponse($authenticatorAttestationResponse = null, $challenge = null)
    public function verifyResponse($credData = null, $challenge = null, $signedData = null)
    {
        $output = new \stdClass();
        $output->fn = 'verify';
        $output->msg = $this->getErrorMessage(4);
        $output->errno = 4;
        $output->next = 'end';

        $sanitizer = $this->wire('sanitizer');
        $session = $this->wire('session');

        $userid = $sanitizer->int($session->getFor('lpk', 'userid'));
        $feUser = $this->wire('users')->get($userid);

        // user passkey saved in DB
        $userPassKeys = $this->_getCredentialsFromDB($feUser);
        // no saved passkeys
        if(\count($userPassKeys) < 1)
            return $output;

        $userPassKey = '';
        foreach($userPassKeys as $passKey) {
            if($passKey['credential_id'] === $credData->id) {
                $userPassKey = $passKey;
                break;
            }
        }

        // didn't find a matching passkey
        if(empty($userPassKey)) {
            $output->msg = $this->_('Failed to verify passkey');
            return $output;
        }

        // got credentials data from the device
        if(!empty($credData)) {

            $getArgs = $this->getlpkargs();
            $clientDataJSON = $this->base64url_decode($credData->response->clientDataJSON);

            // no clientdatajson from the device
            $clientData = \json_decode($clientDataJSON);
            if(!$clientData) {
                $output->msg = $this->_('Failed to decode client data');
                return $output;
            }

            // relying party hosts don't match
            if($clientData->origin !== "https://" . $getArgs->rp) {
                $output->msg = $this->_('Failed to decode client data');
                return $output;
            }

            // challenges dont match
            $clientChallenge = \rtrim($challenge, "=");
            if($clientChallenge !== $clientData->challenge) {
                $output->msg = $this->_('Challenge did not match');
                return $output;
            }

            // credential id's don't match
            if($credData->id !== $userPassKey['credential_id']) {
                $output->msg = $this->_('Credential ID did not match');
                return $output;
            }

            // device failed to sign the request
            if(!$credData->response->signature) {
                $output->msg = $this->_('Signature not created');
                return $output;
            }

            if (strpos($userPassKey['public_key'], 'BEGIN PUBLIC KEY') === false) {
                $output->msg = $this->_('Public key not created');
                $publicKey = $this->publicKeyToPem($userPassKey['public_key']);
            } else {
                $publicKey = $userPassKey['public_key'];
            }

            $signedData = $this->base64url_decode($signedData);
            $signature = $this->base64url_decode($credData->response->signature);

            $key = openssl_pkey_get_public($publicKey);

            if (!$key) {
                $output->msg = $this->_('Failed to open public key');
                return $output;
            } else {
                $isValid = openssl_verify($signedData, $signature, $key, OPENSSL_ALGO_SHA256);
                if(!$isValid === 1) {
                    return $output;
                }
            }

            // now check the user id's match
            $userHandle = $sanitizer->int($this->base64url_decode($credData->response->userHandle));

            if ($userid === $userHandle && $isValid === 1) {
                $session->setFor('lpk', 'success', 'success');
                $output->msg = $this->getErrorMessage(101);
                $output->errno = 101;
            } else {
                $output->msg = $this->_('PassKey name does not match username');
                $output->errno = 99;
            }


        }
        return $output;
    }

    public function getlpkargs()
    {
        $data = wire('modules')->getConfig($this);
        unset($data['enabled']);
        $data['attestation_format'] = $this->attestationFormat;
        $data['crossPlatformAttachment'] = $this->crossPlatformAttachment;
        $data['excludeRegistrations'] = [];

        $output = new \stdClass();
        foreach ($data as $key => $value) {
            $output->$key = $value;
        }
        return $output;
    }

    private function _createChallenge()
    {
        $bytes = random_bytes(32);
        return bin2hex($bytes);
    }


    #---------------------
    # Utility functions
    #---------------------

    public function getErrorMessage($mgsNumber = 99)
    {
        switch ($mgsNumber) {
            case 1:
                return $this->_('Sorry, your browser does not support this feature');
            case 2:
                return $this->_('Failed to create credentials');
            case 3:
                return $this->_("Failed to get authenticator attestation response");
            case 4:
                return $this->_('Failed to verify your passkey. Please use your password to log in.');
            case 5:
                return $this->_('Failed to get authenticator attestation response');
            case 8:
                return $this->_('Failed to verify');
            case 50:
                return $this->_('Please login with your password to register your passkey');
            case 60:
                return $this->_("No username provided");
            case 65:
                return $this->_("No user with name: ");
            case 66:
                return $this->_("Already logged in with passkey");
            case 67:
                return $this->_("Already logged in with password");
            case 70:
                return $this->_("User does not have permission to use WebAuthn");
            case 80:
                return $this->_("User has disallowed role");
            case 90:
                return $this->_("Loggedin user does not match submitted User");
            case 99:
            default:
                return $this->_('Unknown error');
            case 101:
                return $this->_('Verified and logged in successfully');
            case 102:
                return $this->_('Successfully registered');
        }
    }


    public function base64url_decode($data)
    {
        $data = strtr($data, '-_', '+/');
        $padding = strlen($data) % 4;
        if ($padding > 0) {
            $data .= str_repeat('=', 4 - $padding);
        }
        return base64_decode($data);
    }

    function publicKeyToPem($b64url) {
        // Step 1: Convert from base64url to base64
        $b64 = strtr($b64url, '-_', '+/');
        $b64 = rtrim($b64, '='); // remove extra padding if present

        // Step 2: Fix base64 padding (length must be divisible by 4)
        $mod4 = strlen($b64) % 4;
        if ($mod4 > 0) {
            $b64 .= str_repeat('=', 4 - $mod4);
        }

        // Step 3: Chunk the base64 into 64-character lines
        $pemBody = chunk_split($b64, 64, "\n");

        // Step 4: Wrap it in PEM headers
        return "-----BEGIN PUBLIC KEY-----\n" . $pemBody . "-----END PUBLIC KEY-----\n";
    }

    function userAllowed(User $user)
    {
        // Now to see if the FE User is allowed to use WebAuthn
        $allowed = false;
        foreach($user->roles as $role) {
            if (in_array($role->id, $this->roles))
                $allowed = true;
        }
        return $allowed;
    }
    #---------------------
    # Install and Uninstall
    #---------------------

    public function ___install()
    {
        $this->_createTable();

        $templates = $this->wire('templates');
        $files = $this->wire('files');
        $pages = $this->wire('pages');

        $lpkTemplate = $templates->get('name=lpk-api');
        if(!$lpkTemplate) {

            // Create fieldgroup
            $fieldgroup = new Fieldgroup();
            $fieldgroup->name = 'lpk-api';
            $fieldgroup->add('title');

            // save fieldgroup
            $this->wire('fieldgroups')->save($fieldgroup);

            // get fieldgroup
            $fieldgroup = wire('fieldgroups')->get('lpk-api');

            // Create template
            $template = new Template();
            $template->name = 'lpk-api';
            $template->label = 'LoginPassKey API Template';
            $template->fieldgroup = $fieldgroup;
            $template->filename = $this->config->paths->templates . 'lpk-api.php';
            $template->noChildren = 1;
            $template->noParents = -1; // one page only
            $template->urlSegments = "start register verify end";
            $template->contentType = "json";
            $template->https = 1; // always only https
            $template->noAppendTemplateFile = 1; // disable auto-append of eg _main.php
            $template->noUnpublish = 1; // must always be published

            // save template
            $templates->save($template);
        }

        $templateFileExists = $files->exists($this->config->paths->templates . 'lpk-api.php');
        if(!$templateFileExists) {
            $files->copy($this->config->paths($this) . 'lpk-api.php', $this->config->paths->templates . 'lpk-api.php');
        }

        $apiPage = $pages->get("name=lpk-api");
        if($apiPage instanceof NullPage) {
            $apiPage = new Page();
            $apiPage->name = 'lpk-api';
            $apiPage->parent = 1;
            $apiPage->template = 'lpk-api';
            $apiPage->of(false);
            $apiPage->title = $this->_('LoginPassKey API');
            $apiPage->status(['hidden', 'published']);
            $apiPage->save();
        }
    }

    public function ___uninstall()
    {
        $pages = $this->wire('pages');
        $templates = $this->wire('templates');
        $files = $this->wire('files');

        $apiPage = $pages->get('name=lpk-api');
        if(!$apiPage instanceof NullPage) {
            $pages->delete($apiPage);
        }

        $apiTpl = $templates->get('name=lpk-api');
        if($apiTpl instanceof Template) {
            $templates->delete($apiTpl);
        }

        $tplFileExists = $files->exists($this->config->paths->templates . 'lpk-api.php');
        if(!$tplFileExists) {
            $files->unlink($this->config->paths->templates . 'lpk-api.php');
        }


        $this->_deleteTable();
    }

    protected function _createTable()
    {
        $sql =  "DROP TABLE IF EXISTS `" . $this->getTableName() ."`;" .
            "CREATE TABLE `" . $this->getTableName() . "`(".
            "id INT(10) NOT NULL AUTO_INCREMENT, " .
            "user_id INT(10) UNSIGNED NOT NULL, " .
            "credential_id TEXT NOT NULL, " .
            "public_key TEXT NOT NULL, " .
            "created TIMESTAMP NOT NULL default CURRENT_TIMESTAMP, " .
            "PRIMARY KEY (id), " .
            "INDEX user_id_index (user_id) " .
            ") CHARSET=utf8";

        $db = $this->getDatabase();
        return $db->exec($sql);
    }

    protected function _deleteTable()
    {
        $db = $this->getDatabase();
        $sql = "DROP TABLE IF EXISTS " . $this->getTableName();
        $db->exec($sql);
    }
}